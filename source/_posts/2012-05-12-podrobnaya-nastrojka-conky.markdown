---
comments: false
date: 2012-05-12 16:13:55
layout: post
slug: podrobnaya-nastrojka-conky
title: Подробная настройка Conky
wordpress_id: 398
categories:
- GNU/Linux
- Ubuntu desktop
tags:
- conky
- linux
---

### Установка и настройка Conky.

  

**Conky** — системный монитор для **Linux**. **Настройка Conky**. Мониторинг системы в **Linux**.
Официальный источник информаци о [Conky](http://conky.sourceforge.net/aboutconky.html)  
  

Итак, вступление. **Сonky** — многофункциональный полностью настраиваемый системный монитор для **Linux** и BSD систем. Если вы запустите conky сразу после установки, то сможете подумать, что conky — некрасивая и неудобная программа. На самом деле это в корне не так. **Conky** нужно настроить и, если это сделать правильно, все будет супер.
  
  

**Предупреждение**: если вы не хотите утруждать свои нежные мозги чтением непонятных слов и набиранием их вручную с клавиатуры (ужас-то какой!), то до **conky** вы не доросли и можете закрыть эту страницу :Р Если вас это не напугало — 
  
  

Как я уже сказал, чтобы **conky** выглядел хорошо, его надо настроить. Тут два варианта. Первый вариант: найти неплохой но стандартный готовый конфиг и просто использовать его. Найти можно на  http://conky.sourceforge.net/screenshots.html.   

Второй вариант: дочитать эту статью и написать свой на основе готового, добавляя и редактируя его под себя. Благо, это не сложно и интересно. В этой статье я пошагово разберу свой конфиг и опишу настройки кое-каких дополнительных программ, которые пригодятся в работе conky.
  
<!-- more -->  

Вступление закончилось, приступим к делу. **Настройка Conky**  

[Конфиг conky](../perevod-ofytsyalnoj-dokumentatsyy-po-conky) называется _.conkyrc_ и должен лежать в домашней директории пользователя. Он состоит из двух частей: в первой части описываются настройки внешнего вида, а во второй находится то, что будет непосредственно показано на экране.  

Разберем мой конфиг по частям. Пометка: обычный текст - пояснения; текст, выделенный цветом, - строки конфига Conky, их вы можете копировать в свой конфиг, изменяя некоторые параметры под себя. Поехали.
  
  
  

Эти строчки нужны для корректного отображения окна conky. Скорее всего менять их вам не придется.

    
    background no
    own_window yes
    own_window_type override
    own_window_transparent yes
    own_window_hints undecorated,below,sticky,skip_taskbar,skip_pager
    


  

Используем XFT шрифты. Выбор таких шрифтов не велик - Terminus, Vera, Sans и Mono. Вы можете закоментировать эти две строчки и сможете использовать обычные шрифты, но только с XFT шрифтами на моем компьютере conky корректно отображал русские буквы. 

    
    use_xft yes
    xftfont Terminus:size=8


  

Поддержка двойного буфера. Без нее conky будет неприятно мигать.

    
    double_buffer yes


  


Включаем тени - для улучшения читабельности текста.

    
    draw_shades yes

  


Задаем умолчальные цвета

    
    default_color white
    default_shade_color black
    default_outline_color blue


  


Задаем позицию для окна. **Conky** будет отображаться в левом верхнем углу. Можно изменить на top_right, bottom_left, bottom_right

    
    alignment top_left

  


Делаем небольшие отступы с краев

    
    gap_x 10
    gap_y 10
    


  


Так указывается шрифт, если у вас отключено **use_xft yes**. Для определения правильного имени шрифта используйте утилиту **xfontsel**. _Так шрифт можно указывать, если не используется use_xft._ Но без use_xft не отображаются корректно русские буквы. Поэтому пока закоментим.

    
    
    ## font  -schumacher-clean-medium-r-*-*-12-*-*-*-*-*-*-*
    


  
  
  


Эта строчка определяет, как будет показываться свободная/используемая оперативная память. Если **no_buffers no**, то кол-во используемой оперативной памяти будет определяться с учетом кэшированной памяти. Если **no_buffers yes**, кэш будет считаться свободной памятью. Единственного правильного варианта нет. Да и вобще, утилитам которые показывают кол-во свободной/занятой памяти не стоит доверять. Это из-за тонкостей использования динамических библиотек в **Linux**. Если две программы используют библиотеку в 20МБ, это не означает, что каждая из программ занимает +20МБ в ОЗУ. Именно поэтому в некоторых случаях программы, которые используют "жирные" библиотеки типа QT или GTK, на деле используют оперативную память эффективнее чем остальные. Но и это не всегда верно. Также, программа может "занять" себе довольно большой объем оперативки и, с одной стороны память будет занята, но с другой - свободна. Решать вам. Скажу лишь, что с **no_buffers yes**, у меня никогда не "занято" больше 500МБ, а с **no_buffers no** - **Conky** показывает что "занято" постоянно около 3-4ГБ.

    
    no_buffers no

  


Все, первая часть конфига окончена. Переходим ко второй.
  
  

Все, что будет идти после **TEXT**, будет выведено на экран. Минимальная настройка conky может выглядеть так:
TEXT
HELLO

    
    TEXT

  


Сверху у нас будет написана версия ядра системы. "Kernel: ${kernel}" можно заменять на "Ядро: ${kernel}", как вам угодно. Информация берется из переменной $kernel. Если надо указать какие-то дополнительные параметры, имя переменной заключается в фигурные скобки. Да и без параметров обычно так делают - по-привычке, видимо :)

    
    Kernel: ${kernel}

  


Дата и время

    
    Date: ${time}

  


Аптайм системы

    
    Uptime: $uptime

  


**Информация о использовании процессора**. ${color a1ccea} указывает цвет последующего текста. Весь текст, следующий после ${color a1ccea} будет синим, поэтому, после этой строчки мы его сделаем опять белым.  

Если у вас многоядерный процессор, можно выводить информацию с каждого ядра таким образом ${cpu 1} - для первого ядра, #{cpu 2} - для второго и тд.

    
    ${color a1ccea}CPU usage:    $cpu% 

  


Возвращаем цвет в белый и рисуем полоску загруженности процессора высотой 3 и шириной 140 пикселей

    
    ${color ffffff}${cpubar 3,140}

  


Рисуем движущийся график загрузки процессора высотой 20 и шириной 140 пикселей. "000000 ffffff" означают что график будет окрашен градиентно - от белого к черному. Вы можете изменить цвета на свои или вобще убрать "000000 ffffff", тогда график будет просто белый.

    
    ${cpugraph 20,140 000000 ffffff}

  


Показываем три процесса, которые сильнее всего нагружают процессор. Первый окрашиваем оранжевым цветом.

    
    Highest CPU:
    ${color ff9000}${top name 1} ${top cpu 1}%
    

  

Возвращаем цвет текста к белому

    
    ${color ffffff}${top name 2} ${top cpu 2}%
    ${top name 3} ${top cpu 3}%

  


**Использование оперативной памяти**

    
    ${color a1ccea}MEM usage:    $memperc%

  


Пишем количество занятой памяти и общее кол-во озу

    
    ${color ffffff}Used: $mem of $memmax

  


Рисуем полоску использования памяти высотой 3 и шириной 140

    
    ${membar 3,140}

  


Рисуем график использования памяти высотой 20 и шириной 140, закрашенный градиентом

    
    ${memgraph 20,140  000000 ffffff}

  


Показываем три процесса, которые используют памяти больше, чем другие. Самый прожорливый окрашиваем оранжевым цветом.

    
    Highest MEM:
    ${color ff9000}${top_mem name 1} ${top_mem mem 1}%
    ${color ffffff}${top_mem name 2} ${top_mem mem 2}%
    ${top_mem name 3} ${top_mem mem 3}%
    

  

Выводим информацию по использованию свопа

    
    SWAP usage: $swapperc% 
    Used: $swap/$swapmax

  


  

Теперь переходим к **мониторингу сетевых интерфейсов**

    
    ${color a1ccea}Network usage:

  


Показываем исходящий трафик для интерфейса eth0. Если у вас интерфейс называется по-другому, измените eth0 на свое. Если у вас больше одного сетевого интерфейса, просто скопируйте следующие строчки и измените eth0 на свое.

    
    ${color ffffff}
    Up: ${upspeed eth0}/s
    

  

График исходящего трафика

    
    ${upspeedgraph eth0 20,140  000000 ffffff}
    

  

Входящий трафик

    
    Down: ${downspeed eth0}/s

  


График для входящего трафика

    
    ${downspeedgraph eth0 20,140  000000 ffffff}

  

  


**Информация о файловых системах.**  

Тут показывается информация для разделов /, /home и /files
Эти разделы используются на моем компьютере, поэтому измените параметры на нужные

    
    ${color a1ccea}File systems:
    ${color ffffff}

  


Сколько использовано на корневом разделе и сколько места всего

    
     / ${fs_used /}/${fs_size /}

  


Полоска для корневого раздела

    
    ${fs_bar 3,140 /}

  


То-же самое для /home и /files:

    
    Home ${fs_used /home}/${fs_size /home}
    ${fs_bar 3,140 /home}
     /files ${fs_used /files}/${fs_size /files}
    ${fs_bar 3,140 /files}
    

  

  

На **мониторинге температуры** остановимся подробнее.   

Чтобы следить за температурой чипсета материнской платы и температурой процессора, надо установить и настроить пакет **lm_sensors**. Как это делается, написано тут: [Установка и настройка lm_sensors](http://open-way.org/index.php?id=20&ctgr=27&type=2)  

Температуру жесткого диска можно смотреть утилитой **hddtemp**. Просто установите ее, никаких настроек не требуется. Единственная проблема - **hddtemp** использовать может только root. Но мы же не хотим каждый раз запускать conky от рута, поэтому надо разрешить запускать **hddtemp** от пользователя, без прав рута. В Gentoo hddtemp лежит по адресу _/usr/sbin/hddtemp_ и, чтобы разрешить запускать ее от пользователя, надо выполнить от рута команду _chmod a+s /usr/sbin/hddtemp_. Если у вас в /usr/sbin/ ее нету, местоположение файла hddtemp можно узнать командой _whereis hddtemp_ (от рута тоже). Дополнительная проблема в том, что если эта программа у вас обновится, то права надо будет изменить заново.  

Температуру видеокарты, как мне известно, могут смотреть только владельцы Nvidia. Для этого, conky должен быть собран с флагом nvidia (в Gentoo). Во многих дистрибутивах он по умолчанию собирается с поддержкой nvidia.
  
  

**Температура процессора**. Данные берутся с lm_sensors. В моем случае за процессор в lm_sensors отвечает датчик temp1. У вас может быть по-другому.   
Самый простой способ узнать, какой из датчиков за что отвечает, - записать данные с вывода lm_sensors, перезагрузиться и сравнить их с данными о температуре в BIOS

    
    ${color ffffff}CPU:             ${execi 2 sensors | grep temp1 | cut -c 15-16}°С
    

  

**Температура сис. платы.** У меня за нее отвечает temp2. Замените temp2 на другой датчик, если у вас по-другому

    
    SYS:             ${execi 2 sensors | grep temp2 | cut -c 15-16}°С
    

  

**Температура жестких дисков**. Данные берутся с hddtemp. У меня устроства жестких дисков называются /dev/sda и /dev/sdb. Измените это на свое, если у вас по-другому.

    
    /dev/SDA:        ${execi 2 /usr/sbin/hddtemp /dev/sda -q | awk '{print $3; }' | cut -c 1-2}°С
    /dev/SDB:        ${execi 2 /usr/sbin/hddtemp /dev/sdb -q | awk '{print $3; }' | cut -c 1-2}°С
    

  

**Температура видео-карты**. Новые версии Conky поддерживают показ температуры с видеокарт Nvidia. Про ATI ничего не известно

    
    Nvidia GPU:      ${nvidia temp}°С

  

  



* * *


Часть информации была позаимствована по этому адресу на сайте [http://zenux.ru](http://zenux.ru/articles/8/)
